name: Check issues

on:
  workflow_call:
    inputs:
      app-id:
        type: string
        required: true
    secrets:
      app-private-key:
        required: true

jobs:
  run:
    name: Check missing DSMs
    runs-on: ubuntu-latest

    steps:
      - uses: actions/create-github-app-token@v1
        id: app-token
        with:
          app-id: ${{ inputs.app-id }}
          private-key: ${{ secrets.app-private-key }}
          owner: ${{ github.repository_owner }}

      - name: Fetch issues for last 14 days
        id: issues_14d
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const sinceDate = new Date(Date.now() - 14 * 24 * 60 * 60 * 1000);
            const since = sinceDate.toISOString().slice(0, 10);
            const q = [
              `repo:${context.repo.owner}/${context.repo.repo}`,
              'is:issue',
              `created:>=${since}`
            ].join(' ');
            const items = await github.paginate(github.rest.search.issuesAndPullRequests, { q, per_page: 100 });
            const issues = items.map(i => ({
              number: i.number,
              title: i.title,
              url: i.html_url,
              created_at: i.created_at,
            }));
            core.setOutput('issues', JSON.stringify(issues));

      - name: Collect referenced issues from comments
        id: collect_refs
        uses: actions/github-script@v7
        env:
          ISSUES: ${{ steps.issues_14d.outputs.issues }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issues = JSON.parse(process.env.ISSUES || '[]');

            const urlRe = /https?:\/\/github\.com\/([\w.-]+)\/([\w.-]+)\/issues\/(\d+)/gi;
            const crossRefRe = /(^|\s)([\w.-]+)\/([\w.-]+)#(\d+)\b/g;
            const localHashRe = /(^|\s)#(\d+)\b/g;

            const refs = new Map();

            for (const issue of issues) {
              const comments = await github.paginate(github.rest.issues.listComments, {
                owner, repo, issue_number: issue.number, per_page: 100,
              });

              for (const c of comments) {
                const body = c.body || '';

                for (const m of body.matchAll(urlRe)) {
                  const key = `${m[1]}/${m[2]}#${m[3]}`;
                  if (!refs.has(key)) refs.set(key, { owner: m[1], repo: m[2], number: Number(m[3]), sources: new Set() });
                  refs.get(key).sources.add(`#${issue.number}`);
                }

                for (const m of body.matchAll(crossRefRe)) {
                  const key = `${m[2]}/${m[3]}#${m[4]}`;
                  if (!refs.has(key)) refs.set(key, { owner: m[2], repo: m[3], number: Number(m[4]), sources: new Set() });
                  refs.get(key).sources.add(`#${issue.number}`);
                }

                for (const m of body.matchAll(localHashRe)) {
                  const key = `${owner}/${repo}#${m[2]}`;
                  if (!refs.has(key)) refs.set(key, { owner, repo, number: Number(m[2]), sources: new Set() });
                  refs.get(key).sources.add(`#${issue.number}`);
                }
              }
            }

            const referenced = [...refs.values()].map(r => ({
              owner: r.owner,
              repo: r.repo,
              number: r.number,
              url: `https://github.com/${r.owner}/${r.repo}/issues/${r.number}`,
              sources: [...r.sources],
            }));

            await core.summary
              .addHeading(`Собраны ссылки на таски из комментов (${referenced.length})`)
              .addTable([[{data:'Ref',header:true},{data:'From',header:true}]].concat(
                referenced.map(r => [
                  `<a href="${r.url}">${r.owner}/${r.repo}#${r.number}</a>`,
                  r.sources.join(', ')
                ])
              ))
              .write();

            core.setOutput('refs', JSON.stringify(referenced));

      - name: Find latest "текущий статус" comment in referenced issues
        id: check_status
        uses: actions/github-script@v7
        env:
          REFS: ${{ steps.collect_refs.outputs.refs }}
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const owner = context.repo.owner.toLowerCase();
            const repo = context.repo.repo.toLowerCase();
            const refs = (JSON.parse(process.env.REFS || '[]') || []);

            const re = /(текущий статус)|(что сделано)/i;

            const results = [];
            for (const r of refs) {
              let match = null;
              let error = null;
              try {
                console.log(`Search for comments in issue. OWNER: ${r.owner}, REPO: ${r.repo}, ISSUE_NUMBER: ${r.number}`);
                const comments = await github.paginate(github.rest.issues.listComments, {
                  owner: r.owner, repo: r.repo, issue_number: r.number, per_page: 100, direction: "desc"
                });
                console.log(`Found ${comments.length} comments in issue ${r.number} of ${r.repo}`);
                match = comments.find(c => re.test(c.body || '')) || null;
              } catch (e) {
                error = (e && e.status) ? `HTTP ${e.status}` : 'unknown';
              }

              results.push({
                ref: `${r.owner}/${r.repo}#${r.number}`,
                url: r.url,
                hasStatus: Boolean(match),
                matchedAt: match?.created_at || null,
                sources: r.sources,
                commentUrl: match?.html_url || null,
                error
              });
            }

            results.sort((a, b) => {
              if (a.hasStatus === b.hasStatus) {
                const ta = a.matchedAt ? new Date(a.matchedAt).getTime() : 0;
                const tb = b.matchedAt ? new Date(b.matchedAt).getTime() : 0;
                return tb - ta;
              }
              return a.hasStatus ? 1 : -1;
            });

            const table = [
              [{data:'Ref',header:true},{data:'Has "Текущий статус"',header:true},{data:'Comment date',header:true},{data:'From',header:true},{data:'Error',header:true}]
            ];
            for (const r of results) {
              table.push([
                `<a href="${r.url}">${r.ref}</a>`,
                r.hasStatus ? 'YES' : 'NO',
                r.matchedAt ? `<a href="${r.commentUrl}">${new Date(r.matchedAt).toISOString().slice(0, 10)}</a>` : '—',
                r.sources.map(source => `<a href="https://github.com/${owner}/${repo}/issues/${source.replace('#', '')}">${source}</a>`).join(', '),
                r.error || '—'
              ]);
            }

            await core.summary
              .addHeading(`Последний комментарий "Текущий статус" в ссылочных тасках (${results.length})`)
              .addTable(table)
              .write();

            core.setOutput('results', JSON.stringify(results));
